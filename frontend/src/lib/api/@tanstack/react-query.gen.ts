// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, type InfiniteData, infiniteQueryOptions, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { adjustUserCreditsApiV1AdminUsersUserIdCreditsPost, attachImageToItemApiV1ImagesImageIdAttachItemIdPost, classifyImageApiV1ImagesClassifyPost, createCategoryApiV1CategoriesPost, createCategoryFromPathApiV1CategoriesFromPathPost, createCheckoutApiV1BillingCheckoutPost, createItemApiV1ItemsPost, createLocationApiV1LocationsPost, createPackApiV1AdminPacksPost, createPortalSessionApiV1BillingPortalPost, deleteCategoryApiV1CategoriesCategoryIdDelete, deleteImageApiV1ImagesImageIdDelete, deleteItemApiV1ItemsItemIdDelete, deleteLocationApiV1LocationsLocationIdDelete, deletePackApiV1AdminPacksPackIdDelete, getAllTagsApiV1ItemsTagsGet, getBalanceApiV1BillingBalanceGet, getCategoryApiV1CategoriesCategoryIdGet, getCategoryDescendantsApiV1CategoriesCategoryIdDescendantsGet, getCategoryTemplateApiV1CategoriesCategoryIdTemplateGet, getCategoryTreeApiV1CategoriesTreeGet, getCurrentUserInfoApiV1AuthMeGet, getDashboardStatsApiV1ItemsStatsDashboardGet, getImageApiV1ImagesImageIdGet, getImageFileApiV1ImagesImageIdFileGet, getImageSignedUrlApiV1ImagesImageIdSignedUrlGet, getItemApiV1ItemsItemIdGet, getItemFacetsApiV1ItemsFacetsGet, getLocationApiV1LocationsLocationIdGet, getLocationDescendantsApiV1LocationsLocationIdDescendantsGet, getLocationTreeApiV1LocationsTreeGet, getPackApiV1AdminPacksPackIdGet, getStatsApiV1AdminStatsGet, getUserApiV1AdminUsersUserIdGet, googleAuthApiV1AuthGoogleGet, googleCallbackApiV1AuthCallbackGoogleGet, handleWebhookApiV1BillingWebhookPost, healthCheckHealthGet, listCategoriesApiV1CategoriesGet, listClassifiedImagesApiV1ImagesClassifiedGet, listItemsApiV1ItemsGet, listLocationsApiV1LocationsGet, listLowStockItemsApiV1ItemsLowStockGet, listPacksApiV1AdminPacksGet, listPacksApiV1BillingPacksGet, listTransactionsApiV1BillingTransactionsGet, listUsersApiV1AdminUsersGet, moveCategoryApiV1CategoriesCategoryIdMovePatch, moveLocationApiV1LocationsLocationIdMovePatch, type Options, refreshTokenApiV1AuthRefreshPost, requestRefundApiV1BillingRefundPost, searchItemsApiV1ItemsSearchGet, updateCategoryApiV1CategoriesCategoryIdPut, updateItemApiV1ItemsItemIdPut, updateItemQuantityApiV1ItemsItemIdQuantityPatch, updateLocationApiV1LocationsLocationIdPut, updatePackApiV1AdminPacksPackIdPut, updateUserApiV1AdminUsersUserIdPut, uploadImageApiV1ImagesUploadPost } from '../sdk.gen';
import type { AdjustUserCreditsApiV1AdminUsersUserIdCreditsPostData, AdjustUserCreditsApiV1AdminUsersUserIdCreditsPostError, AdjustUserCreditsApiV1AdminUsersUserIdCreditsPostResponse, AttachImageToItemApiV1ImagesImageIdAttachItemIdPostData, AttachImageToItemApiV1ImagesImageIdAttachItemIdPostError, AttachImageToItemApiV1ImagesImageIdAttachItemIdPostResponse, ClassifyImageApiV1ImagesClassifyPostData, ClassifyImageApiV1ImagesClassifyPostError, ClassifyImageApiV1ImagesClassifyPostResponse, CreateCategoryApiV1CategoriesPostData, CreateCategoryApiV1CategoriesPostError, CreateCategoryApiV1CategoriesPostResponse, CreateCategoryFromPathApiV1CategoriesFromPathPostData, CreateCategoryFromPathApiV1CategoriesFromPathPostError, CreateCategoryFromPathApiV1CategoriesFromPathPostResponse, CreateCheckoutApiV1BillingCheckoutPostData, CreateCheckoutApiV1BillingCheckoutPostError, CreateCheckoutApiV1BillingCheckoutPostResponse, CreateItemApiV1ItemsPostData, CreateItemApiV1ItemsPostError, CreateItemApiV1ItemsPostResponse, CreateLocationApiV1LocationsPostData, CreateLocationApiV1LocationsPostError, CreateLocationApiV1LocationsPostResponse, CreatePackApiV1AdminPacksPostData, CreatePackApiV1AdminPacksPostError, CreatePackApiV1AdminPacksPostResponse, CreatePortalSessionApiV1BillingPortalPostData, CreatePortalSessionApiV1BillingPortalPostResponse, DeleteCategoryApiV1CategoriesCategoryIdDeleteData, DeleteCategoryApiV1CategoriesCategoryIdDeleteError, DeleteCategoryApiV1CategoriesCategoryIdDeleteResponse, DeleteImageApiV1ImagesImageIdDeleteData, DeleteImageApiV1ImagesImageIdDeleteError, DeleteImageApiV1ImagesImageIdDeleteResponse, DeleteItemApiV1ItemsItemIdDeleteData, DeleteItemApiV1ItemsItemIdDeleteError, DeleteItemApiV1ItemsItemIdDeleteResponse, DeleteLocationApiV1LocationsLocationIdDeleteData, DeleteLocationApiV1LocationsLocationIdDeleteError, DeleteLocationApiV1LocationsLocationIdDeleteResponse, DeletePackApiV1AdminPacksPackIdDeleteData, DeletePackApiV1AdminPacksPackIdDeleteError, DeletePackApiV1AdminPacksPackIdDeleteResponse, GetAllTagsApiV1ItemsTagsGetData, GetAllTagsApiV1ItemsTagsGetError, GetAllTagsApiV1ItemsTagsGetResponse, GetBalanceApiV1BillingBalanceGetData, GetBalanceApiV1BillingBalanceGetResponse, GetCategoryApiV1CategoriesCategoryIdGetData, GetCategoryApiV1CategoriesCategoryIdGetError, GetCategoryApiV1CategoriesCategoryIdGetResponse, GetCategoryDescendantsApiV1CategoriesCategoryIdDescendantsGetData, GetCategoryDescendantsApiV1CategoriesCategoryIdDescendantsGetError, GetCategoryDescendantsApiV1CategoriesCategoryIdDescendantsGetResponse, GetCategoryTemplateApiV1CategoriesCategoryIdTemplateGetData, GetCategoryTemplateApiV1CategoriesCategoryIdTemplateGetError, GetCategoryTemplateApiV1CategoriesCategoryIdTemplateGetResponse, GetCategoryTreeApiV1CategoriesTreeGetData, GetCategoryTreeApiV1CategoriesTreeGetResponse, GetCurrentUserInfoApiV1AuthMeGetData, GetCurrentUserInfoApiV1AuthMeGetResponse, GetDashboardStatsApiV1ItemsStatsDashboardGetData, GetDashboardStatsApiV1ItemsStatsDashboardGetError, GetDashboardStatsApiV1ItemsStatsDashboardGetResponse, GetImageApiV1ImagesImageIdGetData, GetImageApiV1ImagesImageIdGetError, GetImageApiV1ImagesImageIdGetResponse, GetImageFileApiV1ImagesImageIdFileGetData, GetImageFileApiV1ImagesImageIdFileGetError, GetImageSignedUrlApiV1ImagesImageIdSignedUrlGetData, GetImageSignedUrlApiV1ImagesImageIdSignedUrlGetError, GetImageSignedUrlApiV1ImagesImageIdSignedUrlGetResponse, GetItemApiV1ItemsItemIdGetData, GetItemApiV1ItemsItemIdGetError, GetItemApiV1ItemsItemIdGetResponse, GetItemFacetsApiV1ItemsFacetsGetData, GetItemFacetsApiV1ItemsFacetsGetError, GetItemFacetsApiV1ItemsFacetsGetResponse, GetLocationApiV1LocationsLocationIdGetData, GetLocationApiV1LocationsLocationIdGetError, GetLocationApiV1LocationsLocationIdGetResponse, GetLocationDescendantsApiV1LocationsLocationIdDescendantsGetData, GetLocationDescendantsApiV1LocationsLocationIdDescendantsGetError, GetLocationDescendantsApiV1LocationsLocationIdDescendantsGetResponse, GetLocationTreeApiV1LocationsTreeGetData, GetLocationTreeApiV1LocationsTreeGetResponse, GetPackApiV1AdminPacksPackIdGetData, GetPackApiV1AdminPacksPackIdGetError, GetPackApiV1AdminPacksPackIdGetResponse, GetStatsApiV1AdminStatsGetData, GetStatsApiV1AdminStatsGetResponse, GetUserApiV1AdminUsersUserIdGetData, GetUserApiV1AdminUsersUserIdGetError, GetUserApiV1AdminUsersUserIdGetResponse, GoogleAuthApiV1AuthGoogleGetData, GoogleAuthApiV1AuthGoogleGetError, GoogleAuthApiV1AuthGoogleGetResponse, GoogleCallbackApiV1AuthCallbackGoogleGetData, GoogleCallbackApiV1AuthCallbackGoogleGetError, GoogleCallbackApiV1AuthCallbackGoogleGetResponse, HandleWebhookApiV1BillingWebhookPostData, HandleWebhookApiV1BillingWebhookPostError, HandleWebhookApiV1BillingWebhookPostResponse, HealthCheckHealthGetData, ListCategoriesApiV1CategoriesGetData, ListCategoriesApiV1CategoriesGetResponse, ListClassifiedImagesApiV1ImagesClassifiedGetData, ListClassifiedImagesApiV1ImagesClassifiedGetError, ListClassifiedImagesApiV1ImagesClassifiedGetResponse, ListItemsApiV1ItemsGetData, ListItemsApiV1ItemsGetError, ListItemsApiV1ItemsGetResponse, ListLocationsApiV1LocationsGetData, ListLocationsApiV1LocationsGetResponse, ListLowStockItemsApiV1ItemsLowStockGetData, ListLowStockItemsApiV1ItemsLowStockGetResponse, ListPacksApiV1AdminPacksGetData, ListPacksApiV1AdminPacksGetResponse, ListPacksApiV1BillingPacksGetData, ListPacksApiV1BillingPacksGetResponse, ListTransactionsApiV1BillingTransactionsGetData, ListTransactionsApiV1BillingTransactionsGetError, ListTransactionsApiV1BillingTransactionsGetResponse, ListUsersApiV1AdminUsersGetData, ListUsersApiV1AdminUsersGetError, ListUsersApiV1AdminUsersGetResponse, MoveCategoryApiV1CategoriesCategoryIdMovePatchData, MoveCategoryApiV1CategoriesCategoryIdMovePatchError, MoveCategoryApiV1CategoriesCategoryIdMovePatchResponse, MoveLocationApiV1LocationsLocationIdMovePatchData, MoveLocationApiV1LocationsLocationIdMovePatchError, MoveLocationApiV1LocationsLocationIdMovePatchResponse, RefreshTokenApiV1AuthRefreshPostData, RefreshTokenApiV1AuthRefreshPostResponse, RequestRefundApiV1BillingRefundPostData, RequestRefundApiV1BillingRefundPostError, RequestRefundApiV1BillingRefundPostResponse, SearchItemsApiV1ItemsSearchGetData, SearchItemsApiV1ItemsSearchGetError, SearchItemsApiV1ItemsSearchGetResponse, UpdateCategoryApiV1CategoriesCategoryIdPutData, UpdateCategoryApiV1CategoriesCategoryIdPutError, UpdateCategoryApiV1CategoriesCategoryIdPutResponse, UpdateItemApiV1ItemsItemIdPutData, UpdateItemApiV1ItemsItemIdPutError, UpdateItemApiV1ItemsItemIdPutResponse, UpdateItemQuantityApiV1ItemsItemIdQuantityPatchData, UpdateItemQuantityApiV1ItemsItemIdQuantityPatchError, UpdateItemQuantityApiV1ItemsItemIdQuantityPatchResponse, UpdateLocationApiV1LocationsLocationIdPutData, UpdateLocationApiV1LocationsLocationIdPutError, UpdateLocationApiV1LocationsLocationIdPutResponse, UpdatePackApiV1AdminPacksPackIdPutData, UpdatePackApiV1AdminPacksPackIdPutError, UpdatePackApiV1AdminPacksPackIdPutResponse, UpdateUserApiV1AdminUsersUserIdPutData, UpdateUserApiV1AdminUsersUserIdPutError, UpdateUserApiV1AdminUsersUserIdPutResponse, UploadImageApiV1ImagesUploadPostData, UploadImageApiV1ImagesUploadPostError, UploadImageApiV1ImagesUploadPostResponse } from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const healthCheckHealthGetQueryKey = (options?: Options<HealthCheckHealthGetData>) => createQueryKey('healthCheckHealthGet', options);

/**
 * Health Check
 */
export const healthCheckHealthGetOptions = (options?: Options<HealthCheckHealthGetData>) => queryOptions<unknown, DefaultError, unknown, ReturnType<typeof healthCheckHealthGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await healthCheckHealthGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: healthCheckHealthGetQueryKey(options)
});

export const listPacksApiV1AdminPacksGetQueryKey = (options?: Options<ListPacksApiV1AdminPacksGetData>) => createQueryKey('listPacksApiV1AdminPacksGet', options);

/**
 * List Packs
 *
 * List all credit packs (including inactive) for admin.
 */
export const listPacksApiV1AdminPacksGetOptions = (options?: Options<ListPacksApiV1AdminPacksGetData>) => queryOptions<ListPacksApiV1AdminPacksGetResponse, DefaultError, ListPacksApiV1AdminPacksGetResponse, ReturnType<typeof listPacksApiV1AdminPacksGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listPacksApiV1AdminPacksGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listPacksApiV1AdminPacksGetQueryKey(options)
});

/**
 * Create Pack
 *
 * Create a new credit pack.
 */
export const createPackApiV1AdminPacksPostMutation = (options?: Partial<Options<CreatePackApiV1AdminPacksPostData>>): UseMutationOptions<CreatePackApiV1AdminPacksPostResponse, CreatePackApiV1AdminPacksPostError, Options<CreatePackApiV1AdminPacksPostData>> => {
    const mutationOptions: UseMutationOptions<CreatePackApiV1AdminPacksPostResponse, CreatePackApiV1AdminPacksPostError, Options<CreatePackApiV1AdminPacksPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createPackApiV1AdminPacksPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Pack
 *
 * Delete a credit pack (soft delete by setting inactive).
 */
export const deletePackApiV1AdminPacksPackIdDeleteMutation = (options?: Partial<Options<DeletePackApiV1AdminPacksPackIdDeleteData>>): UseMutationOptions<DeletePackApiV1AdminPacksPackIdDeleteResponse, DeletePackApiV1AdminPacksPackIdDeleteError, Options<DeletePackApiV1AdminPacksPackIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeletePackApiV1AdminPacksPackIdDeleteResponse, DeletePackApiV1AdminPacksPackIdDeleteError, Options<DeletePackApiV1AdminPacksPackIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deletePackApiV1AdminPacksPackIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPackApiV1AdminPacksPackIdGetQueryKey = (options: Options<GetPackApiV1AdminPacksPackIdGetData>) => createQueryKey('getPackApiV1AdminPacksPackIdGet', options);

/**
 * Get Pack
 *
 * Get a specific credit pack.
 */
export const getPackApiV1AdminPacksPackIdGetOptions = (options: Options<GetPackApiV1AdminPacksPackIdGetData>) => queryOptions<GetPackApiV1AdminPacksPackIdGetResponse, GetPackApiV1AdminPacksPackIdGetError, GetPackApiV1AdminPacksPackIdGetResponse, ReturnType<typeof getPackApiV1AdminPacksPackIdGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPackApiV1AdminPacksPackIdGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPackApiV1AdminPacksPackIdGetQueryKey(options)
});

/**
 * Update Pack
 *
 * Update a credit pack.
 */
export const updatePackApiV1AdminPacksPackIdPutMutation = (options?: Partial<Options<UpdatePackApiV1AdminPacksPackIdPutData>>): UseMutationOptions<UpdatePackApiV1AdminPacksPackIdPutResponse, UpdatePackApiV1AdminPacksPackIdPutError, Options<UpdatePackApiV1AdminPacksPackIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdatePackApiV1AdminPacksPackIdPutResponse, UpdatePackApiV1AdminPacksPackIdPutError, Options<UpdatePackApiV1AdminPacksPackIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updatePackApiV1AdminPacksPackIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listUsersApiV1AdminUsersGetQueryKey = (options?: Options<ListUsersApiV1AdminUsersGetData>) => createQueryKey('listUsersApiV1AdminUsersGet', options);

/**
 * List Users
 *
 * List all users with pagination.
 */
export const listUsersApiV1AdminUsersGetOptions = (options?: Options<ListUsersApiV1AdminUsersGetData>) => queryOptions<ListUsersApiV1AdminUsersGetResponse, ListUsersApiV1AdminUsersGetError, ListUsersApiV1AdminUsersGetResponse, ReturnType<typeof listUsersApiV1AdminUsersGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listUsersApiV1AdminUsersGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listUsersApiV1AdminUsersGetQueryKey(options)
});

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = { ...queryKey[0] };
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const listUsersApiV1AdminUsersGetInfiniteQueryKey = (options?: Options<ListUsersApiV1AdminUsersGetData>): QueryKey<Options<ListUsersApiV1AdminUsersGetData>> => createQueryKey('listUsersApiV1AdminUsersGet', options, true);

/**
 * List Users
 *
 * List all users with pagination.
 */
export const listUsersApiV1AdminUsersGetInfiniteOptions = (options?: Options<ListUsersApiV1AdminUsersGetData>) => infiniteQueryOptions<ListUsersApiV1AdminUsersGetResponse, ListUsersApiV1AdminUsersGetError, InfiniteData<ListUsersApiV1AdminUsersGetResponse>, QueryKey<Options<ListUsersApiV1AdminUsersGetData>>, number | Pick<QueryKey<Options<ListUsersApiV1AdminUsersGetData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListUsersApiV1AdminUsersGetData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listUsersApiV1AdminUsersGet({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listUsersApiV1AdminUsersGetInfiniteQueryKey(options)
});

export const getUserApiV1AdminUsersUserIdGetQueryKey = (options: Options<GetUserApiV1AdminUsersUserIdGetData>) => createQueryKey('getUserApiV1AdminUsersUserIdGet', options);

/**
 * Get User
 *
 * Get a specific user.
 */
export const getUserApiV1AdminUsersUserIdGetOptions = (options: Options<GetUserApiV1AdminUsersUserIdGetData>) => queryOptions<GetUserApiV1AdminUsersUserIdGetResponse, GetUserApiV1AdminUsersUserIdGetError, GetUserApiV1AdminUsersUserIdGetResponse, ReturnType<typeof getUserApiV1AdminUsersUserIdGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getUserApiV1AdminUsersUserIdGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getUserApiV1AdminUsersUserIdGetQueryKey(options)
});

/**
 * Update User
 *
 * Update a user (admin status).
 */
export const updateUserApiV1AdminUsersUserIdPutMutation = (options?: Partial<Options<UpdateUserApiV1AdminUsersUserIdPutData>>): UseMutationOptions<UpdateUserApiV1AdminUsersUserIdPutResponse, UpdateUserApiV1AdminUsersUserIdPutError, Options<UpdateUserApiV1AdminUsersUserIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateUserApiV1AdminUsersUserIdPutResponse, UpdateUserApiV1AdminUsersUserIdPutError, Options<UpdateUserApiV1AdminUsersUserIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateUserApiV1AdminUsersUserIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Adjust User Credits
 *
 * Grant or remove credits from a user.
 */
export const adjustUserCreditsApiV1AdminUsersUserIdCreditsPostMutation = (options?: Partial<Options<AdjustUserCreditsApiV1AdminUsersUserIdCreditsPostData>>): UseMutationOptions<AdjustUserCreditsApiV1AdminUsersUserIdCreditsPostResponse, AdjustUserCreditsApiV1AdminUsersUserIdCreditsPostError, Options<AdjustUserCreditsApiV1AdminUsersUserIdCreditsPostData>> => {
    const mutationOptions: UseMutationOptions<AdjustUserCreditsApiV1AdminUsersUserIdCreditsPostResponse, AdjustUserCreditsApiV1AdminUsersUserIdCreditsPostError, Options<AdjustUserCreditsApiV1AdminUsersUserIdCreditsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await adjustUserCreditsApiV1AdminUsersUserIdCreditsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getStatsApiV1AdminStatsGetQueryKey = (options?: Options<GetStatsApiV1AdminStatsGetData>) => createQueryKey('getStatsApiV1AdminStatsGet', options);

/**
 * Get Stats
 *
 * Get admin dashboard statistics.
 */
export const getStatsApiV1AdminStatsGetOptions = (options?: Options<GetStatsApiV1AdminStatsGetData>) => queryOptions<GetStatsApiV1AdminStatsGetResponse, DefaultError, GetStatsApiV1AdminStatsGetResponse, ReturnType<typeof getStatsApiV1AdminStatsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getStatsApiV1AdminStatsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getStatsApiV1AdminStatsGetQueryKey(options)
});

export const googleAuthApiV1AuthGoogleGetQueryKey = (options: Options<GoogleAuthApiV1AuthGoogleGetData>) => createQueryKey('googleAuthApiV1AuthGoogleGet', options);

/**
 * Google Auth
 *
 * Get Google OAuth authorization URL.
 *
 * The client should redirect to this URL to initiate OAuth flow.
 */
export const googleAuthApiV1AuthGoogleGetOptions = (options: Options<GoogleAuthApiV1AuthGoogleGetData>) => queryOptions<GoogleAuthApiV1AuthGoogleGetResponse, GoogleAuthApiV1AuthGoogleGetError, GoogleAuthApiV1AuthGoogleGetResponse, ReturnType<typeof googleAuthApiV1AuthGoogleGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await googleAuthApiV1AuthGoogleGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: googleAuthApiV1AuthGoogleGetQueryKey(options)
});

export const googleCallbackApiV1AuthCallbackGoogleGetQueryKey = (options: Options<GoogleCallbackApiV1AuthCallbackGoogleGetData>) => createQueryKey('googleCallbackApiV1AuthCallbackGoogleGet', options);

/**
 * Google Callback
 *
 * Handle Google OAuth callback.
 *
 * Exchange the authorization code for tokens and create/get user.
 */
export const googleCallbackApiV1AuthCallbackGoogleGetOptions = (options: Options<GoogleCallbackApiV1AuthCallbackGoogleGetData>) => queryOptions<GoogleCallbackApiV1AuthCallbackGoogleGetResponse, GoogleCallbackApiV1AuthCallbackGoogleGetError, GoogleCallbackApiV1AuthCallbackGoogleGetResponse, ReturnType<typeof googleCallbackApiV1AuthCallbackGoogleGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await googleCallbackApiV1AuthCallbackGoogleGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: googleCallbackApiV1AuthCallbackGoogleGetQueryKey(options)
});

export const getCurrentUserInfoApiV1AuthMeGetQueryKey = (options?: Options<GetCurrentUserInfoApiV1AuthMeGetData>) => createQueryKey('getCurrentUserInfoApiV1AuthMeGet', options);

/**
 * Get Current User Info
 *
 * Get the current authenticated user's information.
 */
export const getCurrentUserInfoApiV1AuthMeGetOptions = (options?: Options<GetCurrentUserInfoApiV1AuthMeGetData>) => queryOptions<GetCurrentUserInfoApiV1AuthMeGetResponse, DefaultError, GetCurrentUserInfoApiV1AuthMeGetResponse, ReturnType<typeof getCurrentUserInfoApiV1AuthMeGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCurrentUserInfoApiV1AuthMeGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCurrentUserInfoApiV1AuthMeGetQueryKey(options)
});

/**
 * Refresh Token
 *
 * Refresh the access token.
 */
export const refreshTokenApiV1AuthRefreshPostMutation = (options?: Partial<Options<RefreshTokenApiV1AuthRefreshPostData>>): UseMutationOptions<RefreshTokenApiV1AuthRefreshPostResponse, DefaultError, Options<RefreshTokenApiV1AuthRefreshPostData>> => {
    const mutationOptions: UseMutationOptions<RefreshTokenApiV1AuthRefreshPostResponse, DefaultError, Options<RefreshTokenApiV1AuthRefreshPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await refreshTokenApiV1AuthRefreshPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getBalanceApiV1BillingBalanceGetQueryKey = (options?: Options<GetBalanceApiV1BillingBalanceGetData>) => createQueryKey('getBalanceApiV1BillingBalanceGet', options);

/**
 * Get Balance
 *
 * Get current credit balance for the authenticated user.
 */
export const getBalanceApiV1BillingBalanceGetOptions = (options?: Options<GetBalanceApiV1BillingBalanceGetData>) => queryOptions<GetBalanceApiV1BillingBalanceGetResponse, DefaultError, GetBalanceApiV1BillingBalanceGetResponse, ReturnType<typeof getBalanceApiV1BillingBalanceGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getBalanceApiV1BillingBalanceGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getBalanceApiV1BillingBalanceGetQueryKey(options)
});

export const listPacksApiV1BillingPacksGetQueryKey = (options?: Options<ListPacksApiV1BillingPacksGetData>) => createQueryKey('listPacksApiV1BillingPacksGet', options);

/**
 * List Packs
 *
 * List all available credit packs.
 */
export const listPacksApiV1BillingPacksGetOptions = (options?: Options<ListPacksApiV1BillingPacksGetData>) => queryOptions<ListPacksApiV1BillingPacksGetResponse, DefaultError, ListPacksApiV1BillingPacksGetResponse, ReturnType<typeof listPacksApiV1BillingPacksGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listPacksApiV1BillingPacksGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listPacksApiV1BillingPacksGetQueryKey(options)
});

/**
 * Create Checkout
 *
 * Create a Stripe checkout session for purchasing credits.
 */
export const createCheckoutApiV1BillingCheckoutPostMutation = (options?: Partial<Options<CreateCheckoutApiV1BillingCheckoutPostData>>): UseMutationOptions<CreateCheckoutApiV1BillingCheckoutPostResponse, CreateCheckoutApiV1BillingCheckoutPostError, Options<CreateCheckoutApiV1BillingCheckoutPostData>> => {
    const mutationOptions: UseMutationOptions<CreateCheckoutApiV1BillingCheckoutPostResponse, CreateCheckoutApiV1BillingCheckoutPostError, Options<CreateCheckoutApiV1BillingCheckoutPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createCheckoutApiV1BillingCheckoutPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listTransactionsApiV1BillingTransactionsGetQueryKey = (options?: Options<ListTransactionsApiV1BillingTransactionsGetData>) => createQueryKey('listTransactionsApiV1BillingTransactionsGet', options);

/**
 * List Transactions
 *
 * Get transaction history for the authenticated user.
 */
export const listTransactionsApiV1BillingTransactionsGetOptions = (options?: Options<ListTransactionsApiV1BillingTransactionsGetData>) => queryOptions<ListTransactionsApiV1BillingTransactionsGetResponse, ListTransactionsApiV1BillingTransactionsGetError, ListTransactionsApiV1BillingTransactionsGetResponse, ReturnType<typeof listTransactionsApiV1BillingTransactionsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listTransactionsApiV1BillingTransactionsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listTransactionsApiV1BillingTransactionsGetQueryKey(options)
});

export const listTransactionsApiV1BillingTransactionsGetInfiniteQueryKey = (options?: Options<ListTransactionsApiV1BillingTransactionsGetData>): QueryKey<Options<ListTransactionsApiV1BillingTransactionsGetData>> => createQueryKey('listTransactionsApiV1BillingTransactionsGet', options, true);

/**
 * List Transactions
 *
 * Get transaction history for the authenticated user.
 */
export const listTransactionsApiV1BillingTransactionsGetInfiniteOptions = (options?: Options<ListTransactionsApiV1BillingTransactionsGetData>) => infiniteQueryOptions<ListTransactionsApiV1BillingTransactionsGetResponse, ListTransactionsApiV1BillingTransactionsGetError, InfiniteData<ListTransactionsApiV1BillingTransactionsGetResponse>, QueryKey<Options<ListTransactionsApiV1BillingTransactionsGetData>>, number | Pick<QueryKey<Options<ListTransactionsApiV1BillingTransactionsGetData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListTransactionsApiV1BillingTransactionsGetData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listTransactionsApiV1BillingTransactionsGet({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listTransactionsApiV1BillingTransactionsGetInfiniteQueryKey(options)
});

/**
 * Create Portal Session
 *
 * Create a Stripe customer portal session.
 */
export const createPortalSessionApiV1BillingPortalPostMutation = (options?: Partial<Options<CreatePortalSessionApiV1BillingPortalPostData>>): UseMutationOptions<CreatePortalSessionApiV1BillingPortalPostResponse, DefaultError, Options<CreatePortalSessionApiV1BillingPortalPostData>> => {
    const mutationOptions: UseMutationOptions<CreatePortalSessionApiV1BillingPortalPostResponse, DefaultError, Options<CreatePortalSessionApiV1BillingPortalPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createPortalSessionApiV1BillingPortalPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Request Refund
 *
 * Request a refund for an unused credit purchase.
 */
export const requestRefundApiV1BillingRefundPostMutation = (options?: Partial<Options<RequestRefundApiV1BillingRefundPostData>>): UseMutationOptions<RequestRefundApiV1BillingRefundPostResponse, RequestRefundApiV1BillingRefundPostError, Options<RequestRefundApiV1BillingRefundPostData>> => {
    const mutationOptions: UseMutationOptions<RequestRefundApiV1BillingRefundPostResponse, RequestRefundApiV1BillingRefundPostError, Options<RequestRefundApiV1BillingRefundPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await requestRefundApiV1BillingRefundPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Handle Webhook
 *
 * Handle Stripe webhook events.
 */
export const handleWebhookApiV1BillingWebhookPostMutation = (options?: Partial<Options<HandleWebhookApiV1BillingWebhookPostData>>): UseMutationOptions<HandleWebhookApiV1BillingWebhookPostResponse, HandleWebhookApiV1BillingWebhookPostError, Options<HandleWebhookApiV1BillingWebhookPostData>> => {
    const mutationOptions: UseMutationOptions<HandleWebhookApiV1BillingWebhookPostResponse, HandleWebhookApiV1BillingWebhookPostError, Options<HandleWebhookApiV1BillingWebhookPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await handleWebhookApiV1BillingWebhookPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listItemsApiV1ItemsGetQueryKey = (options?: Options<ListItemsApiV1ItemsGetData>) => createQueryKey('listItemsApiV1ItemsGet', options);

/**
 * List Items
 *
 * List items with filtering and pagination.
 *
 * When filtering by category or location, child categories/locations are included by default.
 * Set include_subcategories=false or include_sublocations=false to filter by exact match only.
 *
 * Filter by tags using ?tags=tag1&tags=tag2 (items must have ALL specified tags).
 * Filter by attributes using ?attr=key1:value1&attr=key2:value2.
 */
export const listItemsApiV1ItemsGetOptions = (options?: Options<ListItemsApiV1ItemsGetData>) => queryOptions<ListItemsApiV1ItemsGetResponse, ListItemsApiV1ItemsGetError, ListItemsApiV1ItemsGetResponse, ReturnType<typeof listItemsApiV1ItemsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listItemsApiV1ItemsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listItemsApiV1ItemsGetQueryKey(options)
});

export const listItemsApiV1ItemsGetInfiniteQueryKey = (options?: Options<ListItemsApiV1ItemsGetData>): QueryKey<Options<ListItemsApiV1ItemsGetData>> => createQueryKey('listItemsApiV1ItemsGet', options, true);

/**
 * List Items
 *
 * List items with filtering and pagination.
 *
 * When filtering by category or location, child categories/locations are included by default.
 * Set include_subcategories=false or include_sublocations=false to filter by exact match only.
 *
 * Filter by tags using ?tags=tag1&tags=tag2 (items must have ALL specified tags).
 * Filter by attributes using ?attr=key1:value1&attr=key2:value2.
 */
export const listItemsApiV1ItemsGetInfiniteOptions = (options?: Options<ListItemsApiV1ItemsGetData>) => infiniteQueryOptions<ListItemsApiV1ItemsGetResponse, ListItemsApiV1ItemsGetError, InfiniteData<ListItemsApiV1ItemsGetResponse>, QueryKey<Options<ListItemsApiV1ItemsGetData>>, number | Pick<QueryKey<Options<ListItemsApiV1ItemsGetData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListItemsApiV1ItemsGetData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listItemsApiV1ItemsGet({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listItemsApiV1ItemsGetInfiniteQueryKey(options)
});

/**
 * Create Item
 *
 * Create a new item.
 */
export const createItemApiV1ItemsPostMutation = (options?: Partial<Options<CreateItemApiV1ItemsPostData>>): UseMutationOptions<CreateItemApiV1ItemsPostResponse, CreateItemApiV1ItemsPostError, Options<CreateItemApiV1ItemsPostData>> => {
    const mutationOptions: UseMutationOptions<CreateItemApiV1ItemsPostResponse, CreateItemApiV1ItemsPostError, Options<CreateItemApiV1ItemsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createItemApiV1ItemsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getDashboardStatsApiV1ItemsStatsDashboardGetQueryKey = (options?: Options<GetDashboardStatsApiV1ItemsStatsDashboardGetData>) => createQueryKey('getDashboardStatsApiV1ItemsStatsDashboardGet', options);

/**
 * Get Dashboard Stats
 *
 * Get dashboard statistics including time series data.
 */
export const getDashboardStatsApiV1ItemsStatsDashboardGetOptions = (options?: Options<GetDashboardStatsApiV1ItemsStatsDashboardGetData>) => queryOptions<GetDashboardStatsApiV1ItemsStatsDashboardGetResponse, GetDashboardStatsApiV1ItemsStatsDashboardGetError, GetDashboardStatsApiV1ItemsStatsDashboardGetResponse, ReturnType<typeof getDashboardStatsApiV1ItemsStatsDashboardGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getDashboardStatsApiV1ItemsStatsDashboardGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getDashboardStatsApiV1ItemsStatsDashboardGetQueryKey(options)
});

export const searchItemsApiV1ItemsSearchGetQueryKey = (options: Options<SearchItemsApiV1ItemsSearchGetData>) => createQueryKey('searchItemsApiV1ItemsSearchGet', options);

/**
 * Search Items
 *
 * Search items by name, description, or tags.
 */
export const searchItemsApiV1ItemsSearchGetOptions = (options: Options<SearchItemsApiV1ItemsSearchGetData>) => queryOptions<SearchItemsApiV1ItemsSearchGetResponse, SearchItemsApiV1ItemsSearchGetError, SearchItemsApiV1ItemsSearchGetResponse, ReturnType<typeof searchItemsApiV1ItemsSearchGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await searchItemsApiV1ItemsSearchGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: searchItemsApiV1ItemsSearchGetQueryKey(options)
});

export const listLowStockItemsApiV1ItemsLowStockGetQueryKey = (options?: Options<ListLowStockItemsApiV1ItemsLowStockGetData>) => createQueryKey('listLowStockItemsApiV1ItemsLowStockGet', options);

/**
 * List Low Stock Items
 *
 * List items that are below their minimum quantity threshold.
 */
export const listLowStockItemsApiV1ItemsLowStockGetOptions = (options?: Options<ListLowStockItemsApiV1ItemsLowStockGetData>) => queryOptions<ListLowStockItemsApiV1ItemsLowStockGetResponse, DefaultError, ListLowStockItemsApiV1ItemsLowStockGetResponse, ReturnType<typeof listLowStockItemsApiV1ItemsLowStockGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listLowStockItemsApiV1ItemsLowStockGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listLowStockItemsApiV1ItemsLowStockGetQueryKey(options)
});

export const getItemFacetsApiV1ItemsFacetsGetQueryKey = (options?: Options<GetItemFacetsApiV1ItemsFacetsGetData>) => createQueryKey('getItemFacetsApiV1ItemsFacetsGet', options);

/**
 * Get Item Facets
 *
 * Get available facets (attribute values with counts) for filtering.
 *
 * Facets are based on the category's attribute template if a category is specified,
 * or all unique attribute keys found in matching items.
 */
export const getItemFacetsApiV1ItemsFacetsGetOptions = (options?: Options<GetItemFacetsApiV1ItemsFacetsGetData>) => queryOptions<GetItemFacetsApiV1ItemsFacetsGetResponse, GetItemFacetsApiV1ItemsFacetsGetError, GetItemFacetsApiV1ItemsFacetsGetResponse, ReturnType<typeof getItemFacetsApiV1ItemsFacetsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getItemFacetsApiV1ItemsFacetsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getItemFacetsApiV1ItemsFacetsGetQueryKey(options)
});

export const getAllTagsApiV1ItemsTagsGetQueryKey = (options?: Options<GetAllTagsApiV1ItemsTagsGetData>) => createQueryKey('getAllTagsApiV1ItemsTagsGet', options);

/**
 * Get All Tags
 *
 * Get all unique tags with their counts.
 */
export const getAllTagsApiV1ItemsTagsGetOptions = (options?: Options<GetAllTagsApiV1ItemsTagsGetData>) => queryOptions<GetAllTagsApiV1ItemsTagsGetResponse, GetAllTagsApiV1ItemsTagsGetError, GetAllTagsApiV1ItemsTagsGetResponse, ReturnType<typeof getAllTagsApiV1ItemsTagsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getAllTagsApiV1ItemsTagsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getAllTagsApiV1ItemsTagsGetQueryKey(options)
});

/**
 * Delete Item
 *
 * Delete an item.
 */
export const deleteItemApiV1ItemsItemIdDeleteMutation = (options?: Partial<Options<DeleteItemApiV1ItemsItemIdDeleteData>>): UseMutationOptions<DeleteItemApiV1ItemsItemIdDeleteResponse, DeleteItemApiV1ItemsItemIdDeleteError, Options<DeleteItemApiV1ItemsItemIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteItemApiV1ItemsItemIdDeleteResponse, DeleteItemApiV1ItemsItemIdDeleteError, Options<DeleteItemApiV1ItemsItemIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteItemApiV1ItemsItemIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getItemApiV1ItemsItemIdGetQueryKey = (options: Options<GetItemApiV1ItemsItemIdGetData>) => createQueryKey('getItemApiV1ItemsItemIdGet', options);

/**
 * Get Item
 *
 * Get an item by ID.
 */
export const getItemApiV1ItemsItemIdGetOptions = (options: Options<GetItemApiV1ItemsItemIdGetData>) => queryOptions<GetItemApiV1ItemsItemIdGetResponse, GetItemApiV1ItemsItemIdGetError, GetItemApiV1ItemsItemIdGetResponse, ReturnType<typeof getItemApiV1ItemsItemIdGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getItemApiV1ItemsItemIdGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getItemApiV1ItemsItemIdGetQueryKey(options)
});

/**
 * Update Item
 *
 * Update an item.
 */
export const updateItemApiV1ItemsItemIdPutMutation = (options?: Partial<Options<UpdateItemApiV1ItemsItemIdPutData>>): UseMutationOptions<UpdateItemApiV1ItemsItemIdPutResponse, UpdateItemApiV1ItemsItemIdPutError, Options<UpdateItemApiV1ItemsItemIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateItemApiV1ItemsItemIdPutResponse, UpdateItemApiV1ItemsItemIdPutError, Options<UpdateItemApiV1ItemsItemIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateItemApiV1ItemsItemIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update Item Quantity
 *
 * Quick update for item quantity.
 */
export const updateItemQuantityApiV1ItemsItemIdQuantityPatchMutation = (options?: Partial<Options<UpdateItemQuantityApiV1ItemsItemIdQuantityPatchData>>): UseMutationOptions<UpdateItemQuantityApiV1ItemsItemIdQuantityPatchResponse, UpdateItemQuantityApiV1ItemsItemIdQuantityPatchError, Options<UpdateItemQuantityApiV1ItemsItemIdQuantityPatchData>> => {
    const mutationOptions: UseMutationOptions<UpdateItemQuantityApiV1ItemsItemIdQuantityPatchResponse, UpdateItemQuantityApiV1ItemsItemIdQuantityPatchError, Options<UpdateItemQuantityApiV1ItemsItemIdQuantityPatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateItemQuantityApiV1ItemsItemIdQuantityPatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listCategoriesApiV1CategoriesGetQueryKey = (options?: Options<ListCategoriesApiV1CategoriesGetData>) => createQueryKey('listCategoriesApiV1CategoriesGet', options);

/**
 * List Categories
 *
 * List all categories for the current user, ordered by hierarchy path.
 */
export const listCategoriesApiV1CategoriesGetOptions = (options?: Options<ListCategoriesApiV1CategoriesGetData>) => queryOptions<ListCategoriesApiV1CategoriesGetResponse, DefaultError, ListCategoriesApiV1CategoriesGetResponse, ReturnType<typeof listCategoriesApiV1CategoriesGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listCategoriesApiV1CategoriesGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listCategoriesApiV1CategoriesGetQueryKey(options)
});

/**
 * Create Category
 *
 * Create a new category.
 */
export const createCategoryApiV1CategoriesPostMutation = (options?: Partial<Options<CreateCategoryApiV1CategoriesPostData>>): UseMutationOptions<CreateCategoryApiV1CategoriesPostResponse, CreateCategoryApiV1CategoriesPostError, Options<CreateCategoryApiV1CategoriesPostData>> => {
    const mutationOptions: UseMutationOptions<CreateCategoryApiV1CategoriesPostResponse, CreateCategoryApiV1CategoriesPostError, Options<CreateCategoryApiV1CategoriesPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createCategoryApiV1CategoriesPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCategoryTreeApiV1CategoriesTreeGetQueryKey = (options?: Options<GetCategoryTreeApiV1CategoriesTreeGetData>) => createQueryKey('getCategoryTreeApiV1CategoriesTreeGet', options);

/**
 * Get Category Tree
 *
 * Get categories as a nested tree structure with item counts.
 */
export const getCategoryTreeApiV1CategoriesTreeGetOptions = (options?: Options<GetCategoryTreeApiV1CategoriesTreeGetData>) => queryOptions<GetCategoryTreeApiV1CategoriesTreeGetResponse, DefaultError, GetCategoryTreeApiV1CategoriesTreeGetResponse, ReturnType<typeof getCategoryTreeApiV1CategoriesTreeGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCategoryTreeApiV1CategoriesTreeGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCategoryTreeApiV1CategoriesTreeGetQueryKey(options)
});

/**
 * Create Category From Path
 *
 * Create categories from an AI-suggested path.
 *
 * Parses a path like 'Hardware > Fasteners > Screws' and creates any
 * missing categories in the hierarchy. Returns the leaf category.
 */
export const createCategoryFromPathApiV1CategoriesFromPathPostMutation = (options?: Partial<Options<CreateCategoryFromPathApiV1CategoriesFromPathPostData>>): UseMutationOptions<CreateCategoryFromPathApiV1CategoriesFromPathPostResponse, CreateCategoryFromPathApiV1CategoriesFromPathPostError, Options<CreateCategoryFromPathApiV1CategoriesFromPathPostData>> => {
    const mutationOptions: UseMutationOptions<CreateCategoryFromPathApiV1CategoriesFromPathPostResponse, CreateCategoryFromPathApiV1CategoriesFromPathPostError, Options<CreateCategoryFromPathApiV1CategoriesFromPathPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createCategoryFromPathApiV1CategoriesFromPathPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete Category
 *
 * Delete a category. Child categories will become root-level categories.
 */
export const deleteCategoryApiV1CategoriesCategoryIdDeleteMutation = (options?: Partial<Options<DeleteCategoryApiV1CategoriesCategoryIdDeleteData>>): UseMutationOptions<DeleteCategoryApiV1CategoriesCategoryIdDeleteResponse, DeleteCategoryApiV1CategoriesCategoryIdDeleteError, Options<DeleteCategoryApiV1CategoriesCategoryIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteCategoryApiV1CategoriesCategoryIdDeleteResponse, DeleteCategoryApiV1CategoriesCategoryIdDeleteError, Options<DeleteCategoryApiV1CategoriesCategoryIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteCategoryApiV1CategoriesCategoryIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCategoryApiV1CategoriesCategoryIdGetQueryKey = (options: Options<GetCategoryApiV1CategoriesCategoryIdGetData>) => createQueryKey('getCategoryApiV1CategoriesCategoryIdGet', options);

/**
 * Get Category
 *
 * Get a category by ID.
 */
export const getCategoryApiV1CategoriesCategoryIdGetOptions = (options: Options<GetCategoryApiV1CategoriesCategoryIdGetData>) => queryOptions<GetCategoryApiV1CategoriesCategoryIdGetResponse, GetCategoryApiV1CategoriesCategoryIdGetError, GetCategoryApiV1CategoriesCategoryIdGetResponse, ReturnType<typeof getCategoryApiV1CategoriesCategoryIdGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCategoryApiV1CategoriesCategoryIdGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCategoryApiV1CategoriesCategoryIdGetQueryKey(options)
});

/**
 * Update Category
 *
 * Update a category.
 */
export const updateCategoryApiV1CategoriesCategoryIdPutMutation = (options?: Partial<Options<UpdateCategoryApiV1CategoriesCategoryIdPutData>>): UseMutationOptions<UpdateCategoryApiV1CategoriesCategoryIdPutResponse, UpdateCategoryApiV1CategoriesCategoryIdPutError, Options<UpdateCategoryApiV1CategoriesCategoryIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateCategoryApiV1CategoriesCategoryIdPutResponse, UpdateCategoryApiV1CategoriesCategoryIdPutError, Options<UpdateCategoryApiV1CategoriesCategoryIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateCategoryApiV1CategoriesCategoryIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCategoryTemplateApiV1CategoriesCategoryIdTemplateGetQueryKey = (options: Options<GetCategoryTemplateApiV1CategoriesCategoryIdTemplateGetData>) => createQueryKey('getCategoryTemplateApiV1CategoriesCategoryIdTemplateGet', options);

/**
 * Get Category Template
 *
 * Get merged attribute template for a category.
 *
 * Returns fields from this category and all ancestors, with child fields
 * overriding parent fields of the same name.
 */
export const getCategoryTemplateApiV1CategoriesCategoryIdTemplateGetOptions = (options: Options<GetCategoryTemplateApiV1CategoriesCategoryIdTemplateGetData>) => queryOptions<GetCategoryTemplateApiV1CategoriesCategoryIdTemplateGetResponse, GetCategoryTemplateApiV1CategoriesCategoryIdTemplateGetError, GetCategoryTemplateApiV1CategoriesCategoryIdTemplateGetResponse, ReturnType<typeof getCategoryTemplateApiV1CategoriesCategoryIdTemplateGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCategoryTemplateApiV1CategoriesCategoryIdTemplateGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCategoryTemplateApiV1CategoriesCategoryIdTemplateGetQueryKey(options)
});

export const getCategoryDescendantsApiV1CategoriesCategoryIdDescendantsGetQueryKey = (options: Options<GetCategoryDescendantsApiV1CategoriesCategoryIdDescendantsGetData>) => createQueryKey('getCategoryDescendantsApiV1CategoriesCategoryIdDescendantsGet', options);

/**
 * Get Category Descendants
 *
 * Get all descendant categories of a category.
 */
export const getCategoryDescendantsApiV1CategoriesCategoryIdDescendantsGetOptions = (options: Options<GetCategoryDescendantsApiV1CategoriesCategoryIdDescendantsGetData>) => queryOptions<GetCategoryDescendantsApiV1CategoriesCategoryIdDescendantsGetResponse, GetCategoryDescendantsApiV1CategoriesCategoryIdDescendantsGetError, GetCategoryDescendantsApiV1CategoriesCategoryIdDescendantsGetResponse, ReturnType<typeof getCategoryDescendantsApiV1CategoriesCategoryIdDescendantsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCategoryDescendantsApiV1CategoriesCategoryIdDescendantsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCategoryDescendantsApiV1CategoriesCategoryIdDescendantsGetQueryKey(options)
});

/**
 * Move Category
 *
 * Move a category to a new parent (or to root level if new_parent_id is null).
 */
export const moveCategoryApiV1CategoriesCategoryIdMovePatchMutation = (options?: Partial<Options<MoveCategoryApiV1CategoriesCategoryIdMovePatchData>>): UseMutationOptions<MoveCategoryApiV1CategoriesCategoryIdMovePatchResponse, MoveCategoryApiV1CategoriesCategoryIdMovePatchError, Options<MoveCategoryApiV1CategoriesCategoryIdMovePatchData>> => {
    const mutationOptions: UseMutationOptions<MoveCategoryApiV1CategoriesCategoryIdMovePatchResponse, MoveCategoryApiV1CategoriesCategoryIdMovePatchError, Options<MoveCategoryApiV1CategoriesCategoryIdMovePatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await moveCategoryApiV1CategoriesCategoryIdMovePatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listLocationsApiV1LocationsGetQueryKey = (options?: Options<ListLocationsApiV1LocationsGetData>) => createQueryKey('listLocationsApiV1LocationsGet', options);

/**
 * List Locations
 *
 * List all locations for the current user, ordered by hierarchy path.
 */
export const listLocationsApiV1LocationsGetOptions = (options?: Options<ListLocationsApiV1LocationsGetData>) => queryOptions<ListLocationsApiV1LocationsGetResponse, DefaultError, ListLocationsApiV1LocationsGetResponse, ReturnType<typeof listLocationsApiV1LocationsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listLocationsApiV1LocationsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listLocationsApiV1LocationsGetQueryKey(options)
});

/**
 * Create Location
 *
 * Create a new location.
 */
export const createLocationApiV1LocationsPostMutation = (options?: Partial<Options<CreateLocationApiV1LocationsPostData>>): UseMutationOptions<CreateLocationApiV1LocationsPostResponse, CreateLocationApiV1LocationsPostError, Options<CreateLocationApiV1LocationsPostData>> => {
    const mutationOptions: UseMutationOptions<CreateLocationApiV1LocationsPostResponse, CreateLocationApiV1LocationsPostError, Options<CreateLocationApiV1LocationsPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await createLocationApiV1LocationsPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLocationTreeApiV1LocationsTreeGetQueryKey = (options?: Options<GetLocationTreeApiV1LocationsTreeGetData>) => createQueryKey('getLocationTreeApiV1LocationsTreeGet', options);

/**
 * Get Location Tree
 *
 * Get locations as a nested tree structure with item counts.
 */
export const getLocationTreeApiV1LocationsTreeGetOptions = (options?: Options<GetLocationTreeApiV1LocationsTreeGetData>) => queryOptions<GetLocationTreeApiV1LocationsTreeGetResponse, DefaultError, GetLocationTreeApiV1LocationsTreeGetResponse, ReturnType<typeof getLocationTreeApiV1LocationsTreeGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getLocationTreeApiV1LocationsTreeGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getLocationTreeApiV1LocationsTreeGetQueryKey(options)
});

/**
 * Delete Location
 *
 * Delete a location. Child locations will become root-level locations.
 */
export const deleteLocationApiV1LocationsLocationIdDeleteMutation = (options?: Partial<Options<DeleteLocationApiV1LocationsLocationIdDeleteData>>): UseMutationOptions<DeleteLocationApiV1LocationsLocationIdDeleteResponse, DeleteLocationApiV1LocationsLocationIdDeleteError, Options<DeleteLocationApiV1LocationsLocationIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteLocationApiV1LocationsLocationIdDeleteResponse, DeleteLocationApiV1LocationsLocationIdDeleteError, Options<DeleteLocationApiV1LocationsLocationIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteLocationApiV1LocationsLocationIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLocationApiV1LocationsLocationIdGetQueryKey = (options: Options<GetLocationApiV1LocationsLocationIdGetData>) => createQueryKey('getLocationApiV1LocationsLocationIdGet', options);

/**
 * Get Location
 *
 * Get a location by ID.
 */
export const getLocationApiV1LocationsLocationIdGetOptions = (options: Options<GetLocationApiV1LocationsLocationIdGetData>) => queryOptions<GetLocationApiV1LocationsLocationIdGetResponse, GetLocationApiV1LocationsLocationIdGetError, GetLocationApiV1LocationsLocationIdGetResponse, ReturnType<typeof getLocationApiV1LocationsLocationIdGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getLocationApiV1LocationsLocationIdGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getLocationApiV1LocationsLocationIdGetQueryKey(options)
});

/**
 * Update Location
 *
 * Update a location.
 */
export const updateLocationApiV1LocationsLocationIdPutMutation = (options?: Partial<Options<UpdateLocationApiV1LocationsLocationIdPutData>>): UseMutationOptions<UpdateLocationApiV1LocationsLocationIdPutResponse, UpdateLocationApiV1LocationsLocationIdPutError, Options<UpdateLocationApiV1LocationsLocationIdPutData>> => {
    const mutationOptions: UseMutationOptions<UpdateLocationApiV1LocationsLocationIdPutResponse, UpdateLocationApiV1LocationsLocationIdPutError, Options<UpdateLocationApiV1LocationsLocationIdPutData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await updateLocationApiV1LocationsLocationIdPut({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLocationDescendantsApiV1LocationsLocationIdDescendantsGetQueryKey = (options: Options<GetLocationDescendantsApiV1LocationsLocationIdDescendantsGetData>) => createQueryKey('getLocationDescendantsApiV1LocationsLocationIdDescendantsGet', options);

/**
 * Get Location Descendants
 *
 * Get all descendant locations of a location.
 */
export const getLocationDescendantsApiV1LocationsLocationIdDescendantsGetOptions = (options: Options<GetLocationDescendantsApiV1LocationsLocationIdDescendantsGetData>) => queryOptions<GetLocationDescendantsApiV1LocationsLocationIdDescendantsGetResponse, GetLocationDescendantsApiV1LocationsLocationIdDescendantsGetError, GetLocationDescendantsApiV1LocationsLocationIdDescendantsGetResponse, ReturnType<typeof getLocationDescendantsApiV1LocationsLocationIdDescendantsGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getLocationDescendantsApiV1LocationsLocationIdDescendantsGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getLocationDescendantsApiV1LocationsLocationIdDescendantsGetQueryKey(options)
});

/**
 * Move Location
 *
 * Move a location to a new parent (or to root level if new_parent_id is null).
 */
export const moveLocationApiV1LocationsLocationIdMovePatchMutation = (options?: Partial<Options<MoveLocationApiV1LocationsLocationIdMovePatchData>>): UseMutationOptions<MoveLocationApiV1LocationsLocationIdMovePatchResponse, MoveLocationApiV1LocationsLocationIdMovePatchError, Options<MoveLocationApiV1LocationsLocationIdMovePatchData>> => {
    const mutationOptions: UseMutationOptions<MoveLocationApiV1LocationsLocationIdMovePatchResponse, MoveLocationApiV1LocationsLocationIdMovePatchError, Options<MoveLocationApiV1LocationsLocationIdMovePatchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await moveLocationApiV1LocationsLocationIdMovePatch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Upload Image
 *
 * Upload an image file.
 *
 * If the same image content was previously uploaded by this user,
 * returns the existing image record instead of creating a duplicate.
 */
export const uploadImageApiV1ImagesUploadPostMutation = (options?: Partial<Options<UploadImageApiV1ImagesUploadPostData>>): UseMutationOptions<UploadImageApiV1ImagesUploadPostResponse, UploadImageApiV1ImagesUploadPostError, Options<UploadImageApiV1ImagesUploadPostData>> => {
    const mutationOptions: UseMutationOptions<UploadImageApiV1ImagesUploadPostResponse, UploadImageApiV1ImagesUploadPostError, Options<UploadImageApiV1ImagesUploadPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await uploadImageApiV1ImagesUploadPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Classify Image
 *
 * Classify an uploaded image using AI.
 */
export const classifyImageApiV1ImagesClassifyPostMutation = (options?: Partial<Options<ClassifyImageApiV1ImagesClassifyPostData>>): UseMutationOptions<ClassifyImageApiV1ImagesClassifyPostResponse, ClassifyImageApiV1ImagesClassifyPostError, Options<ClassifyImageApiV1ImagesClassifyPostData>> => {
    const mutationOptions: UseMutationOptions<ClassifyImageApiV1ImagesClassifyPostResponse, ClassifyImageApiV1ImagesClassifyPostError, Options<ClassifyImageApiV1ImagesClassifyPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await classifyImageApiV1ImagesClassifyPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const listClassifiedImagesApiV1ImagesClassifiedGetQueryKey = (options?: Options<ListClassifiedImagesApiV1ImagesClassifiedGetData>) => createQueryKey('listClassifiedImagesApiV1ImagesClassifiedGet', options);

/**
 * List Classified Images
 *
 * List all images that have been classified by AI.
 */
export const listClassifiedImagesApiV1ImagesClassifiedGetOptions = (options?: Options<ListClassifiedImagesApiV1ImagesClassifiedGetData>) => queryOptions<ListClassifiedImagesApiV1ImagesClassifiedGetResponse, ListClassifiedImagesApiV1ImagesClassifiedGetError, ListClassifiedImagesApiV1ImagesClassifiedGetResponse, ReturnType<typeof listClassifiedImagesApiV1ImagesClassifiedGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await listClassifiedImagesApiV1ImagesClassifiedGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listClassifiedImagesApiV1ImagesClassifiedGetQueryKey(options)
});

export const listClassifiedImagesApiV1ImagesClassifiedGetInfiniteQueryKey = (options?: Options<ListClassifiedImagesApiV1ImagesClassifiedGetData>): QueryKey<Options<ListClassifiedImagesApiV1ImagesClassifiedGetData>> => createQueryKey('listClassifiedImagesApiV1ImagesClassifiedGet', options, true);

/**
 * List Classified Images
 *
 * List all images that have been classified by AI.
 */
export const listClassifiedImagesApiV1ImagesClassifiedGetInfiniteOptions = (options?: Options<ListClassifiedImagesApiV1ImagesClassifiedGetData>) => infiniteQueryOptions<ListClassifiedImagesApiV1ImagesClassifiedGetResponse, ListClassifiedImagesApiV1ImagesClassifiedGetError, InfiniteData<ListClassifiedImagesApiV1ImagesClassifiedGetResponse>, QueryKey<Options<ListClassifiedImagesApiV1ImagesClassifiedGetData>>, number | Pick<QueryKey<Options<ListClassifiedImagesApiV1ImagesClassifiedGetData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
// @ts-ignore
{
    queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<QueryKey<Options<ListClassifiedImagesApiV1ImagesClassifiedGetData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
            query: {
                page: pageParam
            }
        };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await listClassifiedImagesApiV1ImagesClassifiedGet({
            ...options,
            ...params,
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: listClassifiedImagesApiV1ImagesClassifiedGetInfiniteQueryKey(options)
});

/**
 * Delete Image
 *
 * Delete an image.
 */
export const deleteImageApiV1ImagesImageIdDeleteMutation = (options?: Partial<Options<DeleteImageApiV1ImagesImageIdDeleteData>>): UseMutationOptions<DeleteImageApiV1ImagesImageIdDeleteResponse, DeleteImageApiV1ImagesImageIdDeleteError, Options<DeleteImageApiV1ImagesImageIdDeleteData>> => {
    const mutationOptions: UseMutationOptions<DeleteImageApiV1ImagesImageIdDeleteResponse, DeleteImageApiV1ImagesImageIdDeleteError, Options<DeleteImageApiV1ImagesImageIdDeleteData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteImageApiV1ImagesImageIdDelete({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getImageApiV1ImagesImageIdGetQueryKey = (options: Options<GetImageApiV1ImagesImageIdGetData>) => createQueryKey('getImageApiV1ImagesImageIdGet', options);

/**
 * Get Image
 *
 * Get image metadata.
 */
export const getImageApiV1ImagesImageIdGetOptions = (options: Options<GetImageApiV1ImagesImageIdGetData>) => queryOptions<GetImageApiV1ImagesImageIdGetResponse, GetImageApiV1ImagesImageIdGetError, GetImageApiV1ImagesImageIdGetResponse, ReturnType<typeof getImageApiV1ImagesImageIdGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getImageApiV1ImagesImageIdGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getImageApiV1ImagesImageIdGetQueryKey(options)
});

export const getImageSignedUrlApiV1ImagesImageIdSignedUrlGetQueryKey = (options: Options<GetImageSignedUrlApiV1ImagesImageIdSignedUrlGetData>) => createQueryKey('getImageSignedUrlApiV1ImagesImageIdSignedUrlGet', options);

/**
 * Get Image Signed Url
 *
 * Get a signed URL for accessing an image file.
 *
 * This generates a short-lived token that can be used in browser <img> tags
 * where Authorization headers cannot be sent.
 */
export const getImageSignedUrlApiV1ImagesImageIdSignedUrlGetOptions = (options: Options<GetImageSignedUrlApiV1ImagesImageIdSignedUrlGetData>) => queryOptions<GetImageSignedUrlApiV1ImagesImageIdSignedUrlGetResponse, GetImageSignedUrlApiV1ImagesImageIdSignedUrlGetError, GetImageSignedUrlApiV1ImagesImageIdSignedUrlGetResponse, ReturnType<typeof getImageSignedUrlApiV1ImagesImageIdSignedUrlGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getImageSignedUrlApiV1ImagesImageIdSignedUrlGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getImageSignedUrlApiV1ImagesImageIdSignedUrlGetQueryKey(options)
});

export const getImageFileApiV1ImagesImageIdFileGetQueryKey = (options: Options<GetImageFileApiV1ImagesImageIdFileGetData>) => createQueryKey('getImageFileApiV1ImagesImageIdFileGet', options);

/**
 * Get Image File
 *
 * Get the actual image file.
 *
 * Requires a valid signed token query parameter for authentication.
 * Use GET /{image_id}/signed-url to obtain a token.
 */
export const getImageFileApiV1ImagesImageIdFileGetOptions = (options: Options<GetImageFileApiV1ImagesImageIdFileGetData>) => queryOptions<unknown, GetImageFileApiV1ImagesImageIdFileGetError, unknown, ReturnType<typeof getImageFileApiV1ImagesImageIdFileGetQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getImageFileApiV1ImagesImageIdFileGet({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getImageFileApiV1ImagesImageIdFileGetQueryKey(options)
});

/**
 * Attach Image To Item
 *
 * Attach an image to an item.
 */
export const attachImageToItemApiV1ImagesImageIdAttachItemIdPostMutation = (options?: Partial<Options<AttachImageToItemApiV1ImagesImageIdAttachItemIdPostData>>): UseMutationOptions<AttachImageToItemApiV1ImagesImageIdAttachItemIdPostResponse, AttachImageToItemApiV1ImagesImageIdAttachItemIdPostError, Options<AttachImageToItemApiV1ImagesImageIdAttachItemIdPostData>> => {
    const mutationOptions: UseMutationOptions<AttachImageToItemApiV1ImagesImageIdAttachItemIdPostResponse, AttachImageToItemApiV1ImagesImageIdAttachItemIdPostError, Options<AttachImageToItemApiV1ImagesImageIdAttachItemIdPostData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await attachImageToItemApiV1ImagesImageIdAttachItemIdPost({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};
