summary: GitHub Issue Triage
description: |
  Automatically categorizes user issues using OpenAI and creates GitHub issues:
  - Analyzes user-submitted issue text with GPT-4o
  - Categorizes as bug, feature, or question
  - Extracts title, summary, priority, and relevant labels
  - Creates a formatted GitHub issue with appropriate labels
  - Sends optional notification with results

value:
  modules:
    - id: parse_input
      value:
        lock: ""
        type: rawscript
        content: |
          export async function main(
            issue_text: string,
            user_email?: string,
            additional_context?: string
          ): Promise<{
            issue_text: string;
            user_email: string | null;
            additional_context: string | null;
          }> {
            if (!issue_text || issue_text.trim().length < 10) {
              throw new Error("Issue text must be at least 10 characters");
            }

            return {
              issue_text: issue_text.trim(),
              user_email: user_email?.trim() || null,
              additional_context: additional_context?.trim() || null,
            };
          }
        language: deno
        input_transforms:
          issue_text:
            expr: flow_input.body?.issue_text ?? flow_input.issue_text
            type: javascript
          user_email:
            expr: flow_input.body?.user_email ?? flow_input.user_email
            type: javascript
          additional_context:
            expr: flow_input.body?.additional_context ?? flow_input.additional_context
            type: javascript

    - id: fetch_repo_metadata
      value:
        type: branchall
        branches:
          - expr: ""
            modules:
              - id: get_labels
                value:
                  lock: ""
                  type: rawscript
                  content: |
                    export async function main(
                      github_token: string,
                      owner: string,
                      repo: string
                    ): Promise<{ labels: Array<{ name: string; description: string | null }> }> {
                      const response = await fetch(
                        `https://api.github.com/repos/${owner}/${repo}/labels?per_page=100`,
                        {
                          headers: {
                            Authorization: `Bearer ${github_token}`,
                            Accept: "application/vnd.github+json",
                            "X-GitHub-Api-Version": "2022-11-28",
                          },
                        }
                      );

                      if (!response.ok) {
                        throw new Error(`Failed to fetch labels: ${response.status}`);
                      }

                      const data = await response.json();
                      return {
                        labels: data.map((l: any) => ({
                          name: l.name,
                          description: l.description,
                        })),
                      };
                    }
                  language: deno
                  input_transforms:
                    github_token:
                      expr: variable('u/windmill/github_token')
                      type: javascript
                    owner:
                      expr: flow_input.body?.owner ?? flow_input.owner ?? 'mchestr'
                      type: javascript
                    repo:
                      expr: flow_input.body?.repo ?? flow_input.repo ?? 'homerp'
                      type: javascript
            summary: Fetch existing labels
            parallel: true
            skip_failure: true
        parallel: true

    - id: ai_categorize
      value:
        lock: ""
        type: rawscript
        content: |
          export async function main(
            issue_text: string,
            user_email: string | null,
            additional_context: string | null,
            existing_labels: Array<{ name: string; description: string | null }>,
            openai_api_key: string
          ): Promise<{
            category: "bug" | "feature" | "question";
            title: string;
            summary: string;
            priority: "low" | "medium" | "high";
            labels: string[];
          }> {
            const systemPrompt = `You are an issue triage assistant for HomERP, a home inventory management system with AI-powered item classification.

          TASK: Analyze the user's issue and categorize it appropriately.

          CATEGORIES:
          - "bug": Something is broken, not working as expected, or causing errors
          - "feature": A new capability, enhancement, or improvement request
          - "question": User needs help, clarification, or documentation

          TITLE FORMAT:
          - Keep concise, under 80 characters
          - Start with action verb for features (Add, Implement, Enable)
          - Start with issue description for bugs (Fix, Resolve)
          - Be specific but brief

          PRIORITY GUIDELINES:
          - "high": Security issues, data loss, complete feature breakage, blocking issues
          - "medium": Partial functionality issues, significant UX problems, important features
          - "low": Minor improvements, nice-to-haves, cosmetic issues

          EXISTING LABELS IN THE REPO:
          ${JSON.stringify(existing_labels)}

          When suggesting labels, prefer existing labels when they fit. You may suggest new labels if truly necessary.`;

            const userMessage = `Analyze this issue submission:

          Issue Text:
          ${issue_text}

          ${user_email ? `Submitted by: ${user_email}` : ""}
          ${additional_context ? `Additional context: ${additional_context}` : ""}`;

            const response = await fetch("https://api.openai.com/v1/chat/completions", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${openai_api_key}`,
              },
              body: JSON.stringify({
                model: "gpt-4o",
                max_tokens: 1024,
                messages: [
                  { role: "system", content: systemPrompt },
                  { role: "user", content: userMessage },
                ],
                response_format: {
                  type: "json_schema",
                  json_schema: {
                    name: "issue_triage",
                    strict: true,
                    schema: {
                      type: "object",
                      properties: {
                        category: {
                          type: "string",
                          enum: ["bug", "feature", "question"],
                          description: "The issue category",
                        },
                        title: {
                          type: "string",
                          description: "Concise issue title (max 80 chars)",
                        },
                        summary: {
                          type: "string",
                          description: "Well-formatted summary for the GitHub issue body",
                        },
                        priority: {
                          type: "string",
                          enum: ["low", "medium", "high"],
                          description: "Issue priority level",
                        },
                        labels: {
                          type: "array",
                          items: { type: "string" },
                          description: "Relevant labels (1-5)",
                        },
                      },
                      required: ["category", "title", "summary", "priority", "labels"],
                      additionalProperties: false,
                    },
                  },
                },
              }),
            });

            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(`OpenAI API error: ${response.status} - ${errorText}`);
            }

            const data = await response.json();
            const content = data.choices[0].message.content;
            return JSON.parse(content);
          }
        language: deno
        input_transforms:
          issue_text:
            expr: results.parse_input.issue_text
            type: javascript
          user_email:
            expr: results.parse_input.user_email
            type: javascript
          additional_context:
            expr: results.parse_input.additional_context
            type: javascript
          existing_labels:
            expr: results.get_labels?.labels ?? []
            type: javascript
          openai_api_key:
            expr: variable('u/windmill/openai_api_key')
            type: javascript

    - id: process_labels
      value:
        lock: ""
        type: rawscript
        content: |
          export async function main(
            ai_result: {
              category: "bug" | "feature" | "question";
              title: string;
              summary: string;
              priority: "low" | "medium" | "high";
              labels: string[];
            },
            existing_labels: Array<{ name: string; description: string | null }>
          ): Promise<{
            ai_result: typeof ai_result;
            labels_to_create: string[];
            final_labels: string[];
          }> {
            const CATEGORY_LABELS: Record<string, string> = {
              bug: "bug",
              feature: "enhancement",
              question: "question",
            };

            const PRIORITY_LABELS: Record<string, string> = {
              low: "priority: low",
              medium: "priority: medium",
              high: "priority: high",
            };

            const existingLabelNames = new Set(
              existing_labels.map((l) => l.name.toLowerCase())
            );

            // Build final label list
            const allLabels = [
              CATEGORY_LABELS[ai_result.category],
              PRIORITY_LABELS[ai_result.priority],
              ...ai_result.labels,
            ].filter(Boolean);

            // Deduplicate and check which need creation
            const labels_to_create: string[] = [];
            const final_labels: string[] = [];
            const seen = new Set<string>();

            for (const label of allLabels) {
              const lowerLabel = label.toLowerCase();
              if (seen.has(lowerLabel)) continue;
              seen.add(lowerLabel);

              // Find exact match (case-insensitive)
              const existing = existing_labels.find(
                (l) => l.name.toLowerCase() === lowerLabel
              );

              if (existing) {
                final_labels.push(existing.name);
              } else {
                labels_to_create.push(label);
                final_labels.push(label);
              }
            }

            return {
              ai_result,
              labels_to_create,
              final_labels,
            };
          }
        language: deno
        input_transforms:
          ai_result:
            expr: results.ai_categorize
            type: javascript
          existing_labels:
            expr: results.get_labels?.labels ?? []
            type: javascript

    - id: handle_labels
      value:
        type: branchone
        default:
          - id: skip_label_creation
            value:
              lock: ""
              type: rawscript
              content: |
                export async function main(): Promise<{ created: boolean }> {
                  return { created: false };
                }
              language: deno
              input_transforms: {}
        branches:
          - expr: results.process_labels.labels_to_create.length > 0
            modules:
              - id: create_labels_loop
                value:
                  type: forloopflow
                  modules:
                    - id: create_single_label
                      value:
                        lock: ""
                        type: rawscript
                        content: |
                          export async function main(
                            github_token: string,
                            owner: string,
                            repo: string,
                            label_name: string
                          ): Promise<{ label_name: string; created: boolean }> {
                            // Generate a color based on label name
                            const hash = label_name.split('').reduce(
                              (acc, char) => char.charCodeAt(0) + ((acc << 5) - acc), 0
                            );
                            const color = Math.abs(hash).toString(16).substring(0, 6).padEnd(6, '0');

                            const response = await fetch(
                              `https://api.github.com/repos/${owner}/${repo}/labels`,
                              {
                                method: "POST",
                                headers: {
                                  Authorization: `Bearer ${github_token}`,
                                  Accept: "application/vnd.github+json",
                                  "X-GitHub-Api-Version": "2022-11-28",
                                  "Content-Type": "application/json",
                                },
                                body: JSON.stringify({
                                  name: label_name,
                                  color: color,
                                }),
                              }
                            );

                            if (!response.ok && response.status !== 422) {
                              // 422 means label already exists, which is fine
                              const errorText = await response.text();
                              throw new Error(`Failed to create label: ${response.status} - ${errorText}`);
                            }

                            return { label_name, created: response.ok };
                          }
                        language: deno
                        input_transforms:
                          github_token:
                            expr: variable('u/windmill/github_token')
                            type: javascript
                          owner:
                            expr: flow_input.body?.owner ?? flow_input.owner ?? 'mchestr'
                            type: javascript
                          repo:
                            expr: flow_input.body?.repo ?? flow_input.repo ?? 'homerp'
                            type: javascript
                          label_name:
                            expr: flow_input.iter.value
                            type: javascript
                  iterator:
                    expr: results.process_labels.labels_to_create
                    type: javascript
                  parallel: true
                  skip_failures: true
            summary: Create missing labels
            parallel: true
            skip_failure: true

    - id: create_github_issue
      value:
        lock: ""
        type: rawscript
        content: |
          export async function main(
            github_token: string,
            owner: string,
            repo: string,
            ai_result: {
              category: "bug" | "feature" | "question";
              title: string;
              summary: string;
              priority: "low" | "medium" | "high";
              labels: string[];
            },
            final_labels: string[],
            user_email: string | null
          ): Promise<{
            issue_number: number;
            issue_url: string;
            title: string;
          }> {
            const PREFIXES: Record<string, string> = {
              bug: "[Bug]",
              feature: "[Feature]",
              question: "[Question]",
            };

            // Build issue body
            const sections: string[] = [];

            if (ai_result.category === "feature") {
              sections.push("## Feature Request\n");
            } else if (ai_result.category === "bug") {
              sections.push("## Bug Report\n");
            } else {
              sections.push("## Question\n");
            }

            sections.push("### Description\n");
            sections.push(ai_result.summary);
            sections.push("");
            sections.push("---");
            sections.push("");
            sections.push("### Triage Metadata");
            sections.push("");
            sections.push(`- **Category:** ${ai_result.category}`);
            sections.push(`- **Priority:** ${ai_result.priority}`);
            if (user_email) {
              sections.push(`- **Submitted by:** ${user_email}`);
            }
            sections.push(`- **Triaged at:** ${new Date().toISOString()}`);
            sections.push("");
            sections.push("_This issue was automatically created by the Windmill issue triage workflow._");

            const title = `${PREFIXES[ai_result.category]} ${ai_result.title}`;
            const body = sections.join("\n");

            const response = await fetch(
              `https://api.github.com/repos/${owner}/${repo}/issues`,
              {
                method: "POST",
                headers: {
                  Authorization: `Bearer ${github_token}`,
                  Accept: "application/vnd.github+json",
                  "X-GitHub-Api-Version": "2022-11-28",
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({
                  title,
                  body,
                  labels: final_labels,
                }),
              }
            );

            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(`GitHub API error: ${response.status} - ${errorText}`);
            }

            const issue = await response.json();
            return {
              issue_number: issue.number,
              issue_url: issue.html_url,
              title: issue.title,
            };
          }
        language: deno
        input_transforms:
          github_token:
            expr: variable('u/windmill/github_token')
            type: javascript
          owner:
            expr: flow_input.body?.owner ?? flow_input.owner ?? 'mchestr'
            type: javascript
          repo:
            expr: flow_input.body?.repo ?? flow_input.repo ?? 'homerp'
            type: javascript
          ai_result:
            expr: results.process_labels.ai_result
            type: javascript
          final_labels:
            expr: results.process_labels.final_labels
            type: javascript
          user_email:
            expr: results.parse_input.user_email
            type: javascript

    - id: send_notification
      value:
        type: branchone
        default:
          - id: skip_notification
            value:
              lock: ""
              type: rawscript
              content: |
                export async function main(): Promise<{ notified: boolean }> {
                  return { notified: false };
                }
              language: deno
              input_transforms: {}
        branches:
          - expr: (flow_input.body?.notify ?? flow_input.notify) === true
            modules:
              - id: send_pushover
                value:
                  lock: ""
                  type: rawscript
                  content: |
                    export async function main(
                      issue_url: string,
                      issue_title: string,
                      ai_result: {
                        category: string;
                        priority: string;
                        summary: string;
                      },
                      pushover_user_key: string,
                      pushover_api_token: string
                    ): Promise<{ notified: boolean }> {
                      const message = `Category: ${ai_result.category}
                    Priority: ${ai_result.priority}

                    ${ai_result.summary}

                    URL: ${issue_url}`;

                      const response = await fetch("https://api.pushover.net/1/messages.json", {
                        method: "POST",
                        headers: {
                          "Content-Type": "application/json",
                        },
                        body: JSON.stringify({
                          token: pushover_api_token,
                          user: pushover_user_key,
                          title: `Issue Created: ${issue_title}`,
                          message,
                          url: issue_url,
                        }),
                      });

                      if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Pushover API error: ${response.status} - ${errorText}`);
                      }

                      return { notified: true };
                    }
                  language: deno
                  input_transforms:
                    issue_url:
                      expr: results.create_github_issue.issue_url
                      type: javascript
                    issue_title:
                      expr: results.create_github_issue.title
                      type: javascript
                    ai_result:
                      expr: results.process_labels.ai_result
                      type: javascript
                    pushover_user_key:
                      expr: variable('u/windmill/pushover_user_key')
                      type: javascript
                    pushover_api_token:
                      expr: variable('u/windmill/pushover_api_token')
                      type: javascript
            summary: Send Pushover notification
            parallel: true
            skip_failure: true

schema:
  $schema: "https://json-schema.org/draft/2020-12/schema"
  type: object
  order:
    - issue_text
    - user_email
    - additional_context
    - owner
    - repo
    - notify
  properties:
    issue_text:
      type: string
      description: "The user's issue description (min 10 characters)"
      minLength: 10
    user_email:
      type: string
      format: email
      description: "Email of the person submitting the issue (optional)"
    additional_context:
      type: string
      description: "Any additional context about the issue (optional)"
    owner:
      type: string
      description: "GitHub repository owner"
      default: "mchestr"
    repo:
      type: string
      description: "GitHub repository name"
      default: "homerp"
    notify:
      type: boolean
      description: "Send Pushover notification when complete"
      default: false
  required:
    - issue_text

ws_error_handler_muted: false
